<!DOCTYPE html><html lang="en-US"><head>
    <meta charset="utf-8">
    <title>Service Workers</title>
    <link href="../style.css" rel="stylesheet">
    <link href="https://www.w3.org/StyleSheets/TR/W3C-ED" rel="stylesheet">
  </head>
  <body>
    <div class="head">
      <p><a href="http://www.w3.org/"><img alt="W3C" height="48" src="https://www.w3.org/Icons/w3c_home" width="72"></a></p>

      <h1 class="head" id="serviceworker">Service Workers</h1>
      <h2 class="dontpublish no-num no-toc" id="subtitle">Soon-to-be-shipped draft</h2>
      <h2 class="no-num no-toc" id="w3c-doctype">Editor's Draft 11 December 2013</h2>

      <dl>
        <dt>This Version:</dt>
        <dd class="dontpublish"><a href="http://w3c.github.io/serviceworker">http://w3c.github.io/serviceworker</a></dd>
        <dt class="dontpublish">Participate:</dt>
        <dd class="dontpublish">Send feedback to
        <a href="mailto:public-webapps@w3.org?subject=%5BXHR%5D%20">public-webapps@w3.org</a>
        (<a href="http://lists.w3.org/Archives/Public/public-webapps/">archives</a>) or
        <a href="https://www.w3.org/Bugs/Public/enter_bug.cgi?product=WebAppsWG&amp;component=ServiceWorker">file a bug</a>
        (<a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=WebAppsWG&amp;component=ServiceWorker&amp;resolution=---">open bugs</a>)
        <dd class="dontpublish"><a href="http://irc.w3.org">IRC: #webapps</a>

        <dt class="dontpublish">Version History:
        <dd class="dontpublish"><a href="https://dvcs.w3.org/hg/xhr/shortlog">https://dvcs.w3.org/hg/xhr/shortlog</a>

        <dt>Previous Versions:</dt>
        <dd><a href="http://w3c.github.io/serviceworker">http://w3c.github.io/serviceworker</a></dd>

        <dt>Editor:</dt>
        <dd><a href="http://infrequently.org/">Alex Russell</a>,
         <a href="http://www.google.com/">Google</a>
        </dd>
        <dd><a href="mailto:jungkee.song@samsung.com">Jungkee Song</a>,
         <a href="http://www.samsung.com/sec/">Samsung Electronics</a>
        </dd>
      </dl>
    </div>

    <div class="w3conly">
<!--begin-copyright-->
<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2013 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>
<!--end-copyright--></div>

    <hr class="top">

    <div class="dontpublish"><!-- ED version -->
      <h2 class="no-num no-toc" id="specabstract">Abstract</h2>

      <p>This specification describes the method for web applications to enable background functionality, including hooks to enable bootstrapping of web applications while offline.</p>

      <h2 class="no-num no-toc" id="sotd">Status of this Document</h2>

      <p><em>This section describes the status of this document at the time of its
      publication. Other documents may supersede this document. A list of current
      W3C publications and the latest revision of this technical report can be
      found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a>
      at http://www.w3.org/TR/.</em></p>

      <p>This document is published as a snapshot of the
      <a href="http://xhr.spec.whatwg.org/">XMLHttpRequest Living Standard</a>.</p>

      <p>If you wish to make comments regarding this document in a manner
      that is tracked by the W3C, please submit them via using <a href="http://www.w3.org/Bugs/Public/enter_bug.cgi?product=WebAppsWG">our public bug database</a>, or please send comments to
      <a href="mailto:public-webapps@w3.org?subject=%5BXHR%5D%20">public-webapps@w3.org</a>
      (<a href="http://lists.w3.org/Archives/Public/public-webapps/">archived</a>)
      with <samp>[XHR]</samp> at the start of the subject line.</p>

      <p>The W3C <a href="http://www.w3.org/2008/webapps/">Web Applications Working
      Group</a> is the W3C working group responsible for this specification's progress along the W3C Recommendation track. This specification is the 11 December 2013 Editor's Draft.</p>

      <p>Publication as an Editor's Draft does not imply endorsement by the W3C
      Membership. This is a draft document and may be updated, replaced or
      obsoleted by other documents at any time. It is inappropriate to cite this
      document as other than work in progress.</p>

      <p>Work on this specification is also done at the <a href="http://www.whatwg.org/">WHATWG</a>. The W3C Web Applications working group actively pursues convergence of XMLHttpRequest specification with the WHATWG.</p>

      <p>This document was produced by a group operating under the
      <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004
      W3C Patent Policy</a>. W3C maintains a
      <a href="http://www.w3.org/2004/01/pp-impl/42538/status" rel="disclosure">public
      list of any patent disclosures</a> made in connection with the deliverables of
      the group; that page also includes instructions for disclosing a patent. An
      individual who has actual knowledge of a patent which the individual believes
      contains
      <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
      Claim(s)</a> must disclose the information in accordance with
      <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
      6 of the W3C Patent Policy</a>.</p>
    </div>

    <h2 class="no-num no-toc" id="toc">Table of Contents</h2>

<!--begin-toc-->
<ol class="toc">
 <li><a href="#introduction"><span class="secno">1 </span>Introduction</a>
  <ol class="toc">
   <li><a href="#motivations"><span class="secno">1.1 </span>Offline-first web applications: the motivations</a></li>
   <li><a href="#lack-of-the-controllability-with-the-existing-solution:-appcache"><span class="secno">1.2 </span>Lack of the controllability with the existing solution: AppCache</a></li>
   <li><a href="#the-serviceworker"><span class="secno">1.3 </span>The ServiceWorker</a></ol></li>
 <li><a href="#conformance"><span class="secno">2 </span>Conformance</a>
  <ol class="toc">
   <li><a href="#dependencies"><span class="secno">2.1 </span>Dependencies</a></li>
   <li><a href="#extensibility"><span class="secno">2.2 </span>Extensibility</a></ol></li>
 <li><a href="#terminology"><span class="secno">3 </span>Terminology</a></li>
 <li><a href="#interfaces"><span class="secno">4 </span>Interfaces</a>
  <ol class="toc">
   <li><a href="#extensions-to-the-navigator-object"><span class="secno">4.1 </span>Extensions to the <code>Navigator</code> object</a></li>
   <li><a href="#the-serviceworker-interface"><span class="secno">4.2 </span>The <code>ServiceWorker</code> interface</a></li>
   <li><a href="#the-serviceworkerglobalscope-interface"><span class="secno">4.3 </span>The <code>ServiceWorkerGlobalScope</code> interface</a></li>
   <li><a href="#the-installevent-interface"><span class="secno">4.4 </span>The <code>InstallEvent</code> interface</a></li>
   <li><a href="#the-reloadpageevent-interface"><span class="secno">4.5 </span>The <code>ReloadPageEvent</code> interface</a></li>
   <li><a href="#the-fetchevent-interface"><span class="secno">4.6 </span>The <code>FetchEvent</code> interface</a></li>
   <li><a href="#the-request-interface"><span class="secno">4.7 </span>The <code>Request</code> interface</a></li>
   <li><a href="#the-response-interface"><span class="secno">4.8 </span>The <code>Response</code> interface</a></ol></li>
 <li><a href="#bootstrap-with-a-serviceworker"><span class="secno">5 </span>Bootstrap with a ServiceWorker</a>
  <ol class="toc">
   <li><a href="#the-registerserviceworker()-method"><span class="secno">5.1 </span>The <code>registerServiceWorker()</code> method</a></li>
   <li><a href="#the-member-serviceworker-of-the-manifest"><span class="secno">5.2 </span>The member <em><code>serviceworker</code></em> of the manifest</a></li>
   <li><a href="#controlled-and-uncontrolled-documents"><span class="secno">5.3 </span><em>Controlled</em> and <em>uncontrolled</em> documents</a></li>
   <li><a href="#longest-prefix-matching"><span class="secno">5.4 </span>Longest-prefix matching</a></li>
   <li><a href="#last-registration-wins"><span class="secno">5.5 </span>Last-registration wins</a></li>
   <li><a href="#cross-origin-limitation"><span class="secno">5.6 </span>Cross-origin limitation</a></ol></li>
 <li><a href="#lifecycle-of-a-serviceworker"><span class="secno">6 </span>Lifecycle of a ServiceWorker</a></li>
 <li><a href="#upgrade-with-a-new-version"><span class="secno">7 </span>Upgrade with a new version</a>
  <ol class="toc">
   <li><a href="#wait-for-restart"><span class="secno">7.1 </span>Wait-for-restart</a></li>
   <li><a href="#replacement"><span class="secno">7.2 </span>Replacement</a></ol></li>
 <li><a href="#offline-first-resource-handling"><span class="secno">8 </span>Offline-first resource handling</a>
  <ol class="toc">
   <li><a href="#fetchevent-handling"><span class="secno">8.1 </span><code>FetchEvent</code> handling</a></li>
   <li><a href="#navigation-vs-fetch"><span class="secno">8.2 </span>Navigation vs Fetch</a></li>
   <li><a href="#fallback-rule"><span class="secno">8.3 </span>Fallback rule</a></li>
   <li><a href="#redirects"><span class="secno">8.4 </span>Redirects</a></li>
   <li><a href="#cross-origin-resources"><span class="secno">8.5 </span>Cross-origin resources</a></ol></li>
 <li><a href="#caching"><span class="secno">9 </span>Caching</a></li>
 <li><a href="#future-extension"><span class="secno">10 </span>Future extension</a></li>
 <li><a class="no-num" href="#references">References</a></li>
 <li><a class="no-num" href="#acknowledgments">Acknowledgments</a></ol>
<!--end-toc-->

    <h2 id="introduction"><span class="secno">1 </span>Introduction</h2>
    <p><em>This section is non-normative.</em></p>

    <h3 id="motivations"><span class="secno">1.1 </span>Offline-first web applications: the motivations</h3>
    <p>Web applications are traditionally premised on the assumption that the network is reachable. This assumption pervades the platform. HTML documents are loaded over HTTP and traditionally <a class="external" href="http://fetch.spec.whatwg.org/#concept-fetch" title="fetch">fetch</a> all of their sub-resources via subsequent HTTP requests. This places web content at a disadvantage versus other technology stacks.<a href="#refsHTML">[HTML]</a>, <a href="#refsHTTP">[HTTP]</a></p>

    <h3 id="lack-of-the-controllability-with-the-existing-solution:-appcache"><span class="secno">1.2 </span>Lack of the controllability with the existing solution: AppCache</h3>
    <p>AppCache is declarative. Web developers give the browser a manifest and magic happens. This has well-known limitations that <a href="#dfn-serviceworker" title="dfn-serviceworker">ServiceWorker</a>s work around by giving developers the lower-level primitives that AppCache is described in terms of.</p>

    <h3 id="the-serviceworker"><span class="secno">1.3 </span>The ServiceWorker</h3>
    <p><dfn id="dfn-serviceworker" title="dfn-serviceworker">ServiceWorker</dfn>s are a new feature for the web platform that lets a script persistently cache resources and handle all resource requests for an application even when the network is not available. <a href="#dfn-serviceworker" title="dfn-serviceworker">ServiceWorker</a>s are bit of scripts that can listen for network events (such as resource requests), manage content caches, and thus decide what content to display when a URL is requested. <a href="#refsURL">[URL]</a> Putting it all together, <a href="#dfn-serviceworker" title="dfn-serviceworker">ServiceWorker</a>s give you a way to build applications that work offline.</p>

    <div class="example">
      <p>Some simple code to install a service worker and control the document from within the worker script:</p>

      <pre title="Installation from a page">// Document hosted at: http://videos.example.com/index.html
navigator.registerServiceWorker("/assets/v1/serviceworker.js", { scope: "/*" }).then(
  function(serviceWorker) {
    serviceWorker.postMessage("Howdy from your installing page.");
    // To use the serviceWorker immediately, you might call window.location.reload()
  },
  function(why) {
    console.error("Installing the worker failed!:", why);
  });</pre>

      <p>Listen to fetch event and cache necessary resources from the script:</p>
      <pre title="ServiceWorker script">// ServiceWorker script hosted at: http://videos.example.com/assets/v1/serviceworker.js
this.addEventListener("install", function(e) {
  // Tell the system that this service worker can handle fetch events.
  e.services = ["fetch"];
});

this.addEventListener("fetch", function(e) {
  // DIY either offline! or online as fallback.

  // Create a cache of resources. Begins the process of fetching them.
  // URLs are relative to the ServiceWorker
  var shellResources = new Cache(
    base + "/assets/v1/base.css",
    base + "/assets/v1/app.js",
    base + "/assets/v1/logo.png",
    base + "/assets/v1/intro_video.webm",
  );

  // Add Cache to the global so it can be used later during onfetch
  this.caches.set("shell-v1", shellResources);

  // The coast is only clear when all the resources are ready.
  e.waitUntil(shellResources.ready());
});</pre>
    </div>

    <h2 id="conformance"><span class="secno">2 </span>Conformance</h2>

    <p>All diagrams, examples, and notes in this specification are
    non-normative, as are all sections explicitly marked non-normative.
    Everything else in this specification is normative.</p>

    <p>The key words "MUST", "MUST NOT", "REQUIRED", <!--"SHALL", "SHALL
    NOT",--> "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
    "OPTIONAL" in the normative parts of this specification are to be
    interpreted as described in RFC2119. For readability, these words do
    not appear in all uppercase letters in this specification.
    <a href="#refsRFC2119">[RFC2119]</a></p>

    <h3 id="dependencies"><span class="secno">2.1 </span>Dependencies</h3>
    <p>This specification relies on several underlying specifications.</p>

    <ul>
      <li><p>DOM Living Standard <a href="#refsDOM">[DOM]</a></li>
      <li><p>HTML Living Standard <a href="#refsHTML">[HTML]</a></li>
      <li><p>ECMAScript Langauage Specification <a href="#refsECMASCRIPT">[ECMASCRIPT]</a></li>
      <li><p>Web IDL <a href="#refsWEBIDL">[WEBIDL]</a></li>
    </ul>
    <p>It uses the typographic conventions from HTML. <a href="#refsHTML">[HTML]</a></p>

    <h3 id="extensibility"><span class="secno">2.2 </span>Extensibility</h3>

    <p>User agents, Working Groups, and other interested parties are
    <em>strongly encouraged</em> to discuss new features on a relevant public
    forum, preferably
    <a href="mailto:public-webapps@w3.org">public-webapps@w3.org</a>. If this
    is for some reason not possible prefix the extension in some way. E.g. if
    company Foo wants to add a proprietary method <code>bar()</code> it could
    be named <code>fooBar()</code> to prevent clashes with a potential
    non-proprietary method <code>bar()</code>.</p>

    <h2 id="terminology"><span class="secno">3 </span>Terminology</h2>

    <p>The term <dfn id="user-credentials">user credentials</dfn> for the purposes of this
    specification means cookies, HTTP authentication, and client-side SSL
    certificates. Specifically it does not refer to proxy authentication or
    the <code title="http-origin">Origin</code> header.
    <a href="#refsCOOKIES">[COOKIES]</a> <!-- XXX ref? --></p>

    <h2 id="interfaces"><span class="secno">4 </span>Interfaces</h2>
    <p class="note">This section normatively specifies the interfaces and the algorithms for the <a class="internalDFN" href="#dfn-serviceworker">ServiceWorker</a> infrastructure and lifecycle management. Relevant explainer is followed on the subsequent sections: Bootstrapping, Upgrade, <code><a href="#fetchevent">FetchEvent</a></code> and Caching.</p>

    <h3 id="extensions-to-the-navigator-object"><span class="secno">4.1 </span>Extensions to the <code>Navigator</code> object</h3>
    <pre class="idl">partial interface <a class="external" href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#navigator-0">Navigator</a> {
  <a class="external" href="http://w3c.github.io/dom/#promises">Promise</a> <span title="">registerServiceWorker</span>(DOMString <var>url</var>, optional <a href="#serviceworkerscopeoptions">ServiceWorkerScopeOptions</a> <var>options</var>);
  <a class="external" href="http://w3c.github.io/dom/#promises">Promise</a> <span title="">unregisterServiceWorker</span>(<span>ServiceWorker</span> <var>serviceWorker</var>);
          attribute <a class="external" href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#eventhandler">EventHandler</a> <span>onserviceworkerinstall</span>;
          attribute <a class="external" href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#eventhandler">EventHandler</a> <span>onserviceworkerreplaced</span>;
          attribute <a class="external" href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#eventhandler">EventHandler</a> <span>onserviceworkerreloadpage</span>;
};

dictionary <dfn id="serviceworkerscopeoptions" title="ServiceWorkerScopeOptions">ServiceWorkerScopeOptions</dfn> {
  DOMString <span title="">scope</span> = "/*";
};</pre>

    <h3 id="the-serviceworker-interface"><span class="secno">4.2 </span>The <code>ServiceWorker</code> interface</h3>
    <pre class="idl">[NoInterfaceObject]
interface <dfn id="interface-serviceworker" title="interface-ServiceWorker">ServiceWorker</dfn> : <a class="external" href="http://w3c.github.io/dom/#eventtarget">EventTarget</a> {
  void <span title="">postMessage</span>(any <var>message</var>, optional sequence&lt;Transferable&gt; <var>transfer</var>);
          attribute <a class="external" href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#eventhandler">EventHandler</a> <span>onmessage</span>;
};</pre>

    <h3 id="the-serviceworkerglobalscope-interface"><span class="secno">4.3 </span>The <code><a href="#serviceworkerglobalscope">ServiceWorkerGlobalScope</a></code> interface</h3>
    <pre class="idl">[Global]
interface <dfn id="serviceworkerglobalscope">ServiceWorkerGlobalScope</dfn> : <a class="external" href="http://dev.w3.org/html5/workers/#the-workerglobalscope-common-interface">WorkerGlobalScope</a> {
  getter <a class="external" href="http://www.w3.org/html/wg/drafts/html/master/browsers.html#windowproxy">WindowProxy</a>[] windows();
  <a class="external" href="http://w3c.github.io/dom/#promises">Promise</a> <span title="">fetch</span>((<a href="#request">Request</a> or <a class="external" href="http://url.spec.whatwg.org/#url">URL</a> or DOMString or any) <var><a href="#request">request</a></var>);
          attribute <span>CacheList</span> caches;
          attribute any version;
          attribute <a class="external" href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#eventhandler">EventHandler</a> <span>oninstall</span>;
          attribute <a class="external" href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#eventhandler">EventHandler</a> <span>onactivate</span>;
          attribute <a class="external" href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#eventhandler">EventHandler</a> <span>onfetch</span>;
          attribute <a class="external" href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#eventhandler">EventHandler</a> <span>onbeforeevicted</span>;
          attribute <a class="external" href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#eventhandler">EventHandler</a> <span>onevicted</span>;
};</pre>

    <h3 id="the-installevent-interface"><span class="secno">4.4 </span>The <code><a href="#installevent">InstallEvent</a></code> interface</h3>
    <pre class="idl">interface <dfn id="installevent">InstallEvent</dfn> : <a href="#installphaseevent">InstallPhaseEvent</a> {
  void <span>replace</span>();
  <a class="external" href="http://w3c.github.io/dom/#promises">Promise</a> <span>reloadAll</span>();
          attribute <a class="external" href="http://dev.w3.org/html5/postmsg/#messageport">MessagePort</a> previous;
          attribute DOMString[] services;
};

interface <dfn id="installphaseevent">InstallPhaseEvent</dfn> : <a class="external" href="http://w3c.github.io/dom/#event">Event</a> {
  <a class="external" href="http://w3c.github.io/dom/#promises">Promise</a> <span>waitUntil</span>(<a class="external" href="http://w3c.github.io/dom/#promises">Promise</a> <var>f</var>);
          attribute any previousVersion;
};</pre>

    <h3 id="the-reloadpageevent-interface"><span class="secno">4.5 </span>The <code><a href="#reloadpageevent">ReloadPageEvent</a></code> interface</h3>
    <pre class="idl">interface <dfn id="reloadpageevent">ReloadPageEvent</dfn> : <a class="external" href="http://w3c.github.io/dom/#event">Event</a> {
  void <span>waitUntil</span>(<a class="external" href="http://w3c.github.io/dom/#promises">Promise</a> f);
};</pre>

    <h3 id="the-fetchevent-interface"><span class="secno">4.6 </span>The <code><a href="#fetchevent">FetchEvent</a></code> interface</h3>
    <pre class="idl">[Constructor]
interface <dfn id="fetchevent">FetchEvent</dfn> : <a class="external" href="http://w3c.github.io/dom/#event">Event</a> {
  void <span>respondWith</span>((<a class="external" href="http://w3c.github.io/dom/#promises">Promise</a> or <a href="#response">Response</a>) <var>r</var>);
  <a class="external" href="http://w3c.github.io/dom/#promises">Promise</a> <span>forwardTo</span>((<a class="external" href="http://url.spec.whatwg.org/#url">URL</a> or [EnsureUTF16] DOMString) <var>url</var>);
  readonly attribute <a href="#request">Request</a> request;
  readonly attribute <a href="#requesttype">RequestType</a> type;
  readonly attribute <a class="external" href="http://www.w3.org/html/wg/drafts/html/master/browsers.html#windowproxy">WindowProxy</a> window;
  readonly attribute boolean isTopLevel;
  readonly attribute boolean isReload;
};

enum <dfn id="requesttype">RequestType</dfn> {
    "navigate",
    "fetch"
};</pre>

    <h3 id="the-request-interface"><span class="secno">4.7 </span>The <code><a href="#request">Request</a></code> interface</h3>
    <pre class="idl">// <a href="#request">request</a>
[Constructor(optional <a href="#requestinit">RequestInit</a> init)]
interface <dfn id="request">Request</dfn> {
  readonly attribute unsigned long timeout;
  readonly attribute (<a class="external" href="http://url.spec.whatwg.org/#url">URL</a> or [EnsureUTF16] DOMString) url;
  readonly attribute DOMString encoding;
  readonly attribute ByteString method;
  readonly attribute (<a class="external" href="http://url.spec.whatwg.org/#url">URL</a> or [EnsureUTF16] DOMString) origin;
  readonly attribute <a href="#mode">Mode</a> mode;
  readonly attribute boolean synchronous;
  readonly attribute unsigned long redirectCount;
  readonly attribute boolean forcePreflight;
  readonly attribute boolean omitCredentials;
  readonly attribute (<a class="external" href="http://url.spec.whatwg.org/#url">URL</a> or [EnsureUTF16] DOMString) referrer;
  ByteString? <span>getHeader</span>(ByteString <var><a href="#header">header</a></var>);
          attribute sequence&lt;<a href="#header">Header</a>&gt; headers;
  readonly attribute any body;
};

dictionary <dfn id="requestinit">RequestInit</dfn> {
  unsigned long timeout;
  (<a class="external" href="http://url.spec.whatwg.org/#url">URL</a> or [EnsureUTF16] DOMString) url;
  DOMString encoding;
  ByteString method = "GET";
  boolean synchronous = false;
  unsigned long redirectCount = 0;
  boolean forcePreflight = false;
  boolean omitCredentials = false;
  (<a class="external" href="http://url.spec.whatwg.org/#url">URL</a> or [EnsureUTF16] DOMString) referrer;
  sequence&lt;<a href="#header">Header</a>&gt; headers;
  any body = null;
};

enum <dfn id="mode">Mode</dfn> {
  "same origin",
  "tainted x-origin",
  "CORS"
};

dictionary <dfn id="header">Header</dfn> {
  ByteString name;
  ByteString value;
};</pre>

    <h3 id="the-response-interface"><span class="secno">4.8 </span>The <code><a href="#response">Response</a></code> interface</h3>
    <pre class="idl">[Constructor]
interface <dfn id="response">Response</dfn> {
};

[Constructor(optional <a href="#sameoriginresponseinit">SameOriginResponseInit</a> <var>responseInitDict</var>)]
interface <dfn id="sameoriginresponse">SameOriginResponse</dfn> : <a href="#response">Response</a> {
  void <span>setHeader</span>(ByteString <var>name</var>, ByteString <var>value</var>);
  ByteString? <span>getHeader</span>(ByteString <var><a href="#header">header</a></var>);
          attribute sequence&lt;<a href="#header">Header</a>&gt; headers;
          attribute unsigned short statusCode;
          attribute ByteString statusText;
          attribute DOMString encoding;
          attribute ByteString method;
          attribute any body;
};

dictionary <dfn id="sameoriginresponseinit">SameOriginResponseInit</dfn> {
  unsigned short statusCode = 200;
  ByteString statusText = "OK";
  DOMString encoding;
  ByteString method;
  sequence&lt;<a href="#header">Header</a>&gt; headers;
  any body;
};

interface <dfn id="crossoriginresponse">CrossOriginResponse</dfn> : <a href="#response">Response</a> {
};</pre>

    <p class="note" title="About the cache interfaces">
    <code>Cache</code>, <code>CacheList</code> and <code>AsyncMap</code> interfaces will be added.</p>

    <h2 id="bootstrap-with-a-serviceworker"><span class="secno">5 </span>Bootstrap with a ServiceWorker</h2>
    <p>A <span>ServiceWorker</span> MUST be installed either by invoking the <code>navigator.registerServiceWorker()</code> method within web pages or by setting the member <em>serviceworker</em> of the manifest to be the URL of the <span>ServiceWorker</span>.</p>

    <h3 id="the-registerserviceworker()-method"><span class="secno">5.1 </span>The <code>registerServiceWorker()</code> method</h3>
    <p><span>ServiceWorker</span>s MAY be installed by web pages. A user MUST visit a web page or web application for the process to start.</p>
    <div class="example">
      <pre title="Installation">// Document hosted at: http://videos.example.com/index.html
navigator.registerServiceWorker("/assets/v1/ctrl.js", { scope: "/*"}).then(
  function(serviceWorker) {
    console.log("success!");
    serviceWorker.postMessage("Howdy from your installing page.");
    // To use the serviceWorker immediately, you might call window.location.reload()
  },
  function(why) {
    console.error("Installing the worker failed!:", why);
  });</pre>
    </div>

    <p>The example shows the <span>ServiceWorker</span> hosted at <code>/assets/v1/ctrl.js</code> is installed by the web page hosted at <code>http://videos.example.com/index.html</code>.</p>
    <div class="example">
      <pre title="ServiceWorker script serving onfetch event">// ServiceWorker script hosted at: /assets/v1/ctrl.js
this.version = 1;

var base = "http://videos.example.com";
var inventory = new URL("/services/inventory/data.json", base);

this.addEventListener("install", function(e) {
  // Tell the system that this service worker can handle fetch events.
  e.services = ["fetch"];
});

this.addEventListener("fetch", function(e) {
  var url = e.request.url;
  console.log(url);
  if (url.toString() == inventory.toString()) {
    e.respondWith(new SameOriginResponse({
      statusCode: 200,
      body: JSON.stringify({
        videos: { /* ... */ }
      })
    }));
  }
});
        </pre>
    </div>
    <p>
    Once the <code>ctrl.js</code> in the example is successfully installed, the "success!"" message will be sent to the console and, crucially, the next time the user visits <code>index.html</code> or any other page located at <code>http://videos.example.com/</code>, <code>ctrl.js</code> will be consulted about what to do and what content to load even if the device has no Internet connection. On pages that are <em>controlled</em> in this way, other resources (like images in the document body) are also requested first from <code>ctrl.js</code> before the normal browser cache is consulted for them.</p>

    <h3 id="the-member-serviceworker-of-the-manifest"><span class="secno">5.2 </span>The member <em><code>serviceworker</code></em> of the manifest</h3>
    <p class="note">Issue: this section remains unspecified as neither the architecture has been clarified nor has it been aligned with the standards track <a class="external" href="http://w3c.github.io/manifest/">manifest</a> specification.</p>

    <h3 id="controlled-and-uncontrolled-documents"><span class="secno">5.3 </span><em>Controlled</em> and <em>uncontrolled</em> documents</h3>
    <p>The first time <code>http://videos.example.com/index.html</code> is loaded, all the resources it requests will come from the network. That means that even if the browser runs the install snippet for <code>ctrl.js</code>, <a class="external" href="http://fetch.spec.whatwg.org/#concept-fetch">fetch</a>es it, and finishes installing it before it begins <a class="external" href="http://fetch.spec.whatwg.org/#concept-fetch">fetch</a>ing logo.png, the new <span>ServiceWorker</span> script would not be consulted about loading logo.png. This is down to the following rule of <span>ServiceWorker</span>s:</p>
    <ul>
      <li>Documents live out their whole lives using the ServiceWorker they start with.</li>
    </ul>
    <p>This means that if a document starts life without a <span>ServiceWorker</span>, even if one is installed for a matching bit of URL space, it would not suddenly get a <span>ServiceWorker</span> later in life. Same goes for documents that are loaded with a <span>ServiceWorker</span> which might later call <code>navigator.unregisterServiceWorker()</code>. Put another way, <code>registerServiceWorker()</code> and <code>unregisterServiceWorker()</code> only affect the next document(s).</p>


    <h3 id="longest-prefix-matching"><span class="secno">5.4 </span>Longest-prefix matching</h3>
    <div class="example">
      <pre title="Longest-prefix matching [ex 1]">&lt;!DOCTYPE html&gt;
&lt;!-- http://www.example.com/foo.html --&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script&gt;
      navigator.registerServiceWorker("/fooServiceWorker.js", { scope: "/foo*"});
    &lt;/script&gt;
  &lt;/head&gt;
&lt;/html&gt;</pre>
      <pre title="Longest-prefix matching [ex 2]">&lt;!DOCTYPE html&gt;
&lt;!-- http://www.example.com/foo/bar.html --&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script&gt;
      navigator.registerServiceWorker("/foo/barServiceWorker.js", { scope: "/foo/bar*" });
    &lt;/script&gt;
  &lt;/head&gt;
&lt;/html&gt;</pre>
    </div>
    <p>To break what might otherwise be ties when matching URLs, navigations are mapped to <span>ServiceWorker</span>s by longest-prefix-match. Note that the <code>*</code> can only occur at the end of a matching rule, so attempts to register <code>/foo/*/bar</code> or <code>*bar</code> will <a class="external" href="http://dev.w3.org/2006/webapi/WebIDL/#dfn-throw">throw</a> exceptions. Similarly, registering a scope that includes a <code>"?"</code> or <code>"#"</code> will also <a class="external" href="http://dev.w3.org/2006/webapi/WebIDL/#dfn-throw">throw</a>s exceptions.</p>
    <p>In the above example with registrations for <code>/foo*</code> and <code>/foo/bar*</code>, the following matches would be made when navigating to the following URLs under <code>http://www.example.com</code>:</p>
    <table border="1">
      <tr>
        <th>Scope (Pattern)</th>
        <th>URL</th>
      </tr>
      <tr>
        <td><code>/foo</code></td>
        <td><code>/fooServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foo?blarg</code></td>
        <td><code>/fooServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foo/</code></td>
        <td><code>/fooServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foo/thinger.html</code></td>
        <td><code>/fooServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foobar.html</code></td>
        <td><code>/fooServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foo/other/thinger.html</code></td>
        <td><code>/fooServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foo/bar</code></td>
        <td><code>/foo/barServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foo/bar/</code></td>
        <td><code>/foo/barServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foo/bar/thinger.html</code></td>
        <td><code>/foo/barServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foo/bar/baz/thinger.html</code></td>
        <td><code>/foo/barServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/index.html</code></td>
        <td><code>&lt;fallback to native&gt;</code></td>
      </tr>
      <tr>
        <td><code>/whatevs/index.html</code></td>
        <td><code>&lt;fallback to native&gt;</code></td>
      </tr>
    </table>
    <p><code>&lt;fallback to native&gt;</code> is the browser's built-in behavior for fetching resources - the thing the Fetch Service defers to when it does not handle a fetch with <code>e.respondWith()</code>.</p>
    <p class="note">If <code>e.respondWith()</code> is not called when handling a connection in <code>/foo/barServiceWorker.js</code>, it does not cascade to <code>/fooServiceWorker.js</code>, it falls back to the browser's built-in network behavior.</p>

    <h3 id="last-registration-wins"><span class="secno">5.5 </span>Last-registration wins</h3>
    <p>The registration system is also last-registration-wins. That means if two pages on <code>www.example.com</code> set a registration to control <code>/*</code>, the one a user visits second (assuming the first does not interfere) will be installed and over-write the previous registration.</p>

    <p>This makes sense because registration is the same as replacement. That is to say, if you have content that wants to replace the existing <span>ServiceWorker</span> with one at a different URL (perhaps a heavy-handed form of "new version"), registering the new URL is the way that you indicate that the old registration is no longer the preferred one.</p>

    <h3 id="cross-origin-limitation"><span class="secno">5.6 </span>Cross-origin limitation</h3>
    <p>One of the concerns that major applications hit is "how do I host things from a CDN?" By definition, these are servers in other places, often on other domains, that your content references. Can <span>ServiceWorker</span>s be hosted on CDNs? No, this is not allowed since <span>ServiceWorker</span>s can create the possibility of an XSS vulnerability, etc.</p>

    <p>But they can include resources (via <code>importScripts()</code>) that are.</p>

    <h2 id="lifecycle-of-a-serviceworker"><span class="secno">6 </span>Lifecycle of a ServiceWorker</h2>
    <p>The browser might unceremoniously kill your <span>ServiceWorker</span> if it is idle, or even stop it mid-work and re-issue the request to a different instance of the worker. There are no guarantees about how long a <span>ServiceWorker</span> will run. <span>ServiceWorker</span>s should be written to avoid holding global state. This cannot be stressed enough: write your workers as though they will die after every request.</p>
    <p>Also remember that <span>ServiceWorker</span>s are shared resources. A single worker might be servicing requests from multiple tabs or documents. Never assume that only one document is talking to a given <span>ServiceWorker</span>. If you care about where a request is coming from or going to, use the <code>.window</code> property of the <code>onfetch</code> event; but do not create state that you care about without serializing it somewhere like IndexedDB.</p>


    <h2 id="upgrade-with-a-new-version"><span class="secno">7 </span>Upgrade with a new version</h2>

    <h3 id="wait-for-restart"><span class="secno">7.1 </span>Wait-for-restart</h3>
    <p>The default policy is that this new tab will be controlled by v1. This is done to prevent the crazy-town scenario of multiple <span>ServiceWorker</span> versions running at the same time, possibly creating conflicts for IndexedDB schemas, content caches, and the like. Yes, there is a small window during <code>oninstall</code> when v2 will be running at the same time as v1, but they would not both be serving content. The advice then is: do not do irreversible things during oninstall. It is a good place to get a jump on populating caches (with unique names if the new content is reliant on the new <span>ServiceWorker</span>), but a bad place to do things like schema and model upgrades for your application.</p>

    <p>The alternative scenario is one in which the new version of your <span>ServiceWorker</span> is discovered and installed and no documents are running against v1. This could happen because:</p>

    <ul>
      <li>v1 was installed by a page that was loaded "naked", but which was never reloaded so as to start under the <span>ServiceWorker</span>.</li>
      <li>The browser fetched an update of it is own volition. It is allowed to do that!</li>
      <li>Between the time <code>oninstall</code> started for the v2 <span>ServiceWorker</span> and when <code>waitUntil()</code> was finally satisfied, all of the application's windows were closed.</li>
    </ul>

    <p>When this happens, v2 instantly becomes the active <span>ServiceWorker</span>, so the next time you navigate to a URL controlled by the registration, v2 would get first crack at it.</p>

    <p>Indeed, v2 will become the active <span>ServiceWorker</span> just as soon as all v1 documents are closed.</p>

    <p>When v2 does become the active <span>ServiceWorker</span>, another event - <code>onactivate</code> - is sent to v2. This happens before any fetches are dispatched. This is the ideal time to upgrade database schemas and the like, but be careful not to do too much work. Applications will be blocked from loading while <code>onactivate</code> is being serviced (including any extensions asked for via <code>e.waitUntil()</code>, which is also available to <code>onactivate</code> handlers). Treat <code>onactivate</code> as a time to stake your claim as the new version but beware doing more than that lest you make your app unavailable!</p>

    <h3 id="replacement"><span class="secno">7.2 </span>Replacement</h3>
    <p>An alternative policy is available for the daring: a new <span>ServiceWorker</span> can choose to cut-in and replace an existing one. And before you ask, yes, this does break the first rule. But not much.</p>

    <p>To replace an existing <span>ServiceWorker</span>, use the <code>.replace()</code> method of the <code>oninstall</code> event during the event dispatch. In fact, you can even call <code>.replace()</code> on the very first install of a <span>ServiceWorker</span>, which will now make your <span>ServiceWorker</span> the proud owner of all windows/tabs whose URLs match the registration origin and scope including the page that registered it.</p>

    <p>Here is an example: we'll compare the versions to ensure that they are not so far apart that stepping in would break things; leaving the old <span>ServiceWorker</span> in place if the version skew is too great and taking over if it is a difference our new version is confident it can handle. Consider v1.3 vs. v1.0:</p>

    <div class="example">
      <pre title="Replacement">// caching.js
this.version = 1.3;

var assetBase = "/assets/v" + parseInt(this.version) + "/";
var shellCacheName = "shell-v" + parseInt(this.version);
var contentCacheName = "content";

this.addEventListener("install", function(e) {
  e.services = ["fetch"];

  // Create a cache of resources. Begins the process of fetching them.
  var shellResources = new Cache(
    assetBase + "/base.css",
    assetBase + "/app.js",
    assetBase + "/logo.png",
    assetBase + "/intro_video.webm",
  );

  // Add Cache to the global so it can be used later during onfetch
  this.caches.set(shellCacheName, shellResources);

  // Prepare an additional cache that we can add items to later
  if (!this.caches.has(contentCacheName)) {
    this.caches.set(contentCacheName, new Cache());
  }

  // The coast is only clear when all the resources are ready.
  e.waitUntil(shellResources.ready());

  // If and only if we're less than one major version ahead, cut-in and start
  // serving resources.
  if (parseInt(e.previousVersion) == parseInt(this.version)) {
    // Note: replacement won't happen until the Promise passed to
    // e.waitUntil resolves
    e.replace();
  }
});

// ...onfetch, etc...</pre>
    </div>
    <p>The <code>previousVersion</code> field of the event is filled in using a structured clone of the global version property set by the last execution of the previous <span>ServiceWorker</span>. It is a good idea both to always set a version and, sort of obviously, not to make it something that can't be cloned or which varies.</p>

    <p>What of the old <span>ServiceWorker</span>? What happens to it?</p>

    <p>The replacing <span>ServiceWorker</span> can send a message to the old <span>ServiceWorker</span> in <code>oninstalled</code> using <code>e.previous.postMessage()</code>. This can blossom into a bi-directional discussion if both sides have registered <code>onmessage</code> handlers, but that is out of the scope of this document for now.</p>

    <h2 id="offline-first-resource-handling"><span class="secno">8 </span>Offline-first resource handling</h2>

    <h3 id="fetchevent-handling"><span class="secno">8.1 </span><code><a href="#fetchevent">FetchEvent</a></code> handling</h3>
    <p><span>ServiceWorker</span>s, once installed, can choose to handle resource loading. Before going to the network to <a class="external" href="http://fetch.spec.whatwg.org/#concept-fetch">fetch</a> a document that matches the ServiceWorker's scope, the worker is consulted, including when <a class="external" href="http://fetch.spec.whatwg.org/#concept-fetch">fetch</a>ing the document payload itself.

    Here is an example of a <span>ServiceWorker</span> that only handles a single resource (<code>/services/inventory/data.json</code>) but which logs out requests for all resources it is consulted for:</p>

    <div class="example">
      <pre title="onfetch handling in a ServiceWorker">// hosted at: /assets/v1/ctrl.js
this.version = 1;

var base = "http://videos.example.com";
var inventory = new URL("/services/inventory/data.json", base);

this.addEventListener("install", function(e) {
  // Tell the system that this service worker can handle fetch events.
  e.services = ["fetch"];
});

this.addEventListener("fetch", function(e) {
  var url = e.request.url;
  console.log(url);
  if (url.toString() == inventory.toString()) {
    e.respondWith(new SameOriginResponse({
      statusCode: 200,
      body: JSON.stringify({
        videos: { /* ... */ }
      })
    }));
  }
});</pre>
    </div>
    <p>The contents of all but the inventory will be handled by the normal browser resource fetching system because the onfetch event handler did not call <code>respondWith</code> when invoked with their requests. The first time the app is loaded (before the <span>ServiceWorker</span> is installed), <code>data.json</code> will also be fetched from the network. Thereafter it will be computed by the <span>ServiceWorker</span> instead. The important thing to remember here is that normal resource loading is the fallback behavior for fetch events.</p>
    <p>When combined with access to IndexedDB and a new form of <code>Cache</code>, the ability to respond with arbitrary content is incredibly powerful. Since installed <span>ServiceWorker</span>s are invoked even when offline, <span>ServiceWorker</span>s enable apps that are "offline by default" once installed.</p>

    <h3 id="navigation-vs-fetch"><span class="secno">8.2 </span>Navigation vs Fetch</h3>
    <p>Description</p>

    <h3 id="fallback-rule"><span class="secno">8.3 </span>Fallback rule</h3>
    <p>Description</p>

    <h3 id="redirects"><span class="secno">8.4 </span>Redirects</h3>
    <p>Description</p>

    <h3 id="cross-origin-resources"><span class="secno">8.5 </span>Cross-origin resources</h3>
    <p>Description</p>

    <h2 id="caching"><span class="secno">9 </span>Caching</h2>
    <div class="example">
      <pre title="Cache control in ServiceWorker script">// ServiceWorker script hosted at: /assets/v1/caching.js
this.version = 1;

var base = "http://videos.example.com";
this.addEventListener("install", function(e) {
  e.services = ["fetch"];

  // Create a cache of resources. Begins the process of fetching them.
  // URLs are relative to the ServiceWorker
  var shellResources = new Cache(
    base + "/assets/v1/base.css",
    base + "/assets/v1/app.js",
    base + "/assets/v1/logo.png",
    base + "/assets/v1/intro_video.webm",
  );

  // Add Cache to the global so it can be used later during onfetch
  this.caches.set("shell-v1", shellResources);

  // The coast is only clear when all the resources are ready.
  e.waitUntil(shellResources.ready());
});</pre>
    </div>
    <p class="note" title="Further woker needed">
    Issue: is it better to bake the Cache related interfaces separate from this draft? Further woker needed.</p>

    <h2 id="future-extension"><span class="secno">10 </span>Future extension</h2>
    <p class="note">Issue: need to address the requirements from SysApps WG use cases and more. Currently, TaskScheduler and notification would be the scope of this work. Security sensitive features will be considered as V2.</p>

    <h2 class="no-num" id="references">References</h2>
    <div id="anolis-references"><dl><dt id="refsCOOKIES">[COOKIES]
<dd><cite><a href="http://tools.ietf.org/html/rfc6265">HTTP State Management Mechanism</a></cite>, Adam Barth. IETF.

<dt id="refsDOM">[DOM]
<dd><cite><a href="http://www.w3.org/TR/dom/">DOM</a></cite>, Anne van Kesteren, Aryeh Gregor and Ms2ger. W3C.

<dt id="refsECMASCRIPT">[ECMASCRIPT]
<dd><cite><a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAScript Language Specification</a></cite>. ECMA.

<dt id="refsHTML">[HTML]
<dd><cite><a href="http://www.w3.org/TR/html5/">HTML</a></cite>, Robin Berjon, Travis Leithead, Erika Doyle Navara et al.. W3C.

<dt id="refsHTTP">[HTTP]
<dd><cite><a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a></cite>, Roy Fielding, James Gettys, Jeffrey Mogul et al.. IETF.

<dt id="refsRFC2119">[RFC2119]
<dd><cite><a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a></cite>, Scott Bradner. IETF.

<dt id="refsURL">[URL]
<dd><cite><a href="http://url.spec.whatwg.org/">URL Standard</a></cite>, Anne van Kesteren. WHATWG.

<dt id="refsWEBIDL">[WEBIDL]
<dd><cite><a href="http://dev.w3.org/2006/webapi/WebIDL/">Web IDL</a></cite>, Cameron McCormack. W3C.

</dl></div>

    <h2 class="no-num" id="acknowledgments">Acknowledgments</h2>

    <p>The editor would like to thank
    alecf,
    Jake Archibald,
    Dominique Hazael-Massieux,
    Anne Van Kesteren,
    Anssi Kostiainen,
    Michael Sanford,
    sole,
    Ivan Žužak
    for their contributions to this specification.</p>

    <p>Thanks also to all those who have helped to improve this specification
    by sending suggestions and corrections. (Please, keep bugging us with your
    issues!)</p>


