<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset=utf-8>
    <title>Service Workers</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://www.w3.org/StyleSheets/TR/W3C-[STATUS]">
  </head>
  <body>
    <div class="head">
      <p><a href="http://www.w3.org/"><img width="72" height="48" src="https://www.w3.org/Icons/w3c_home" alt="W3C"></a></p>

      <h1 class="head" id="serviceworker">Service Workers</h1>
      <h2 class="dontpublish no-num no-toc" id="subtitle">Soon-to-be-shipped draft</h2>
      <h2 class="no-num no-toc" id="w3c-doctype">[LONGSTATUS] [DATE: 3 August 2002]</h2>

      <dl>
        <dt>This Version:</dt>
        <dd class=dontpublish><a href="http://w3c.github.io/serviceworker">http://w3c.github.io/serviceworker</a></dd>
        <dd class=publish><a href="[VERSION]">[VERSION]</a></dd>

        <dt class=dontpublish>Participate:</dt>
        <dd class=dontpublish>Send feedback to
        <a href="mailto:public-webapps@w3.org?subject=%ServiceWorker%5D%20">public-webapps@w3.org</a>
        (<a href="http://lists.w3.org/Archives/Public/public-webapps/">archives</a>) or
        <a href="https://www.w3.org/Bugs/Public/enter_bug.cgi?product=WebAppsWG&amp;component=ServiceWorker">file a bug</a>
        (<a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=WebAppsWG&amp;component=ServiceWorker&amp;resolution=---">open bugs</a>)
        <dd class=dontpublish><a href="http://irc.w3.org">IRC: #webapps</a>

        <dt class=dontpublish>Version History:
        <dd class=dontpublish><a href="https://github.com/jungkees/ServiceWorker-Proposal/commits/gh-pages">https://github.com/jungkees/ServiceWorker-Proposal/commits/gh-pages</a>

        <dt class=publish>Latest Version:</dt>
        <dd class=publish><a href="[LATEST]">[LATEST]</a></dd>

        <dt class=publish>Latest Editor Draft:</dt>
        <dd class=publish><a href="http://w3c.github.io/serviceworker">http://w3c.github.io/serviceworker</a></dd>

        <dt>Previous Versions:</dt>
        <dd><a href="http://w3c.github.io/serviceworker">http://w3c.github.io/serviceworker</a></dd>

        <dt>Editor:</dt>
        <dd><a href="http://infrequently.org/">Alex Russell</a>,
         <a href="http://www.google.com/">Google</a>
        </dd>
        <dd><a href="mailto:jungkee.song@samsung.com">Jungkee Song</a>,
         <a href="http://www.samsung.com/sec/">Samsung Electronics</a>
        </dd>
      </dl>
    </div>

    <div class=w3conly><!--copyright--></div>

    <hr class="top">

    <div class=dontpublish><!-- ED version -->
      <h2 class="no-num no-toc" id="specabstract">Abstract</h2>

      <p>This specification describes the method for web applications to enable background functionality, including hooks to enable bootstrapping of web applications while offline.</p>

      <h2 class="no-num no-toc" id="sotd">Status of this Document</h2>

      <p><em>This section describes the status of this document at the time of its
      publication. Other documents may supersede this document. A list of current
      W3C publications and the latest revision of this technical report can be
      found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a>
      at http://www.w3.org/TR/.</em></p>

      <p>If you wish to make comments regarding this document in a manner
      that is tracked by the W3C, please submit them via using <a href="http://www.w3.org/Bugs/Public/enter_bug.cgi?product=WebAppsWG">our public bug database</a>, or please send comments to
      <a href="mailto:public-webapps@w3.org?subject=%5BServiceWorker%5D%20">public-webapps@w3.org</a>
      (<a href="http://lists.w3.org/Archives/Public/public-webapps/">archived</a>)
      with <samp>[ServiceWorker]</samp> at the start of the subject line.</p>

      <p>The W3C <a href="http://www.w3.org/2008/webapps/">Web Applications Working
      Group</a> is the W3C working group responsible for this specification's progress along the W3C Recommendation track. This specification is the [DATE: 8 October 2012] Editor's Draft.</p>

      <p>Publication as an Editor's Draft does not imply endorsement by the W3C
      Membership. This is a draft document and may be updated, replaced or
      obsoleted by other documents at any time. It is inappropriate to cite this
      document as other than work in progress.</p>

      <p>This document was produced by a group operating under the
      <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004
      W3C Patent Policy</a>. W3C maintains a
      <a rel="disclosure" href="http://www.w3.org/2004/01/pp-impl/42538/status">public
      list of any patent disclosures</a> made in connection with the deliverables of
      the group; that page also includes instructions for disclosing a patent. An
      individual who has actual knowledge of a patent which the individual believes
      contains
      <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
      Claim(s)</a> must disclose the information in accordance with
      <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
      6 of the W3C Patent Policy</a>.</p>
    </div>

    <div class=publish><!-- publication version -->
      <h2 class="no-num no-toc" id="specabstract">Abstract</h2>

      <p>This specification describes the method for web applications to enable background functionality, including hooks to enable bootstrapping of web applications while offline.</p>

      <h2 class="no-num no-toc" id="sotd">Status of this Document</h2>

      <p><em>This section describes the status of this document at the time of its
      publication. Other documents may supersede this document. A list of current
      W3C publications and the latest revision of this technical report can be
      found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a>
      at http://www.w3.org/TR/.</em></p>

      <p>If you wish to make comments regarding this document in a manner
      that is tracked by the W3C, please submit them via using <a href="http://www.w3.org/Bugs/Public/enter_bug.cgi?product=WebAppsWG">our public bug database</a>, or please send comments to
      <a href="mailto:public-webapps@w3.org?subject=%5BServiceWorker%5D%20">public-webapps@w3.org</a>
      (<a href="http://lists.w3.org/Archives/Public/public-webapps/">archived</a>)
      with <samp>[ServiceWorker]</samp> at the start of the subject line.</p>

      <p>The W3C <a href="http://www.w3.org/2008/webapps/">Web Applications Working
      Group</a> is the W3C working group responsible for this specification's progress along the W3C Recommendation track. This specification is the [DATE: 8 October 2012] Working Draft.</p>

      <p>Publication as a Working Draft does not imply endorsement by the W3C
      Membership. This is a draft document and may be updated, replaced or
      obsoleted by other documents at any time. It is inappropriate to cite this
      document as other than work in progress.</p>

      <p>This document was produced by a group operating under the
      <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004
      W3C Patent Policy</a>. W3C maintains a
      <a rel="disclosure" href="http://www.w3.org/2004/01/pp-impl/42538/status">public
      list of any patent disclosures</a> made in connection with the deliverables of
      the group; that page also includes instructions for disclosing a patent. An
      individual who has actual knowledge of a patent which the individual believes
      contains
      <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
      Claim(s)</a> must disclose the information in accordance with
      <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
      6 of the W3C Patent Policy</a>.</p>
    </div>

    <h2 class="no-num no-toc" id="toc">Table of Contents</h2>
    <!--toc-->

    <h2 id="introduction">Introduction</h2>
    <p><em>This section is non-normative.</em></p>

    <h3 id="motivations">Offline-first web applications: the motivations</h3>
    <p>Web applications are traditionally premised on the assumption that the network is reachable. This assumption pervades the platform. <span data-anolis-ref>HTML</span> documents are loaded over HTTP and traditionally <span data-anolis-spec=fetch title=fetch>fetch</span> all of their sub-resources via subsequent <span data-anolis-ref>HTTP</span> requests. This places web content at a disadvantage versus other technology stacks.</p>

    <h3>Lack of the controllability with the existing solution: AppCache</h3>
    <p>AppCache is declarative. Web developers give the browser a manifest and magic happens. This has well-known limitations that the <span title=concept-serviceworker>service worker</span>s work around by giving developers the lower-level primitives that AppCache is described in terms of.</p>

    <h3>Service workers</h3>
    <p><dfn title=concept-serviceworker>Service worker</dfn>s are a new feature for the web platform that lets a script persistently cache resources and handle all resource requests for an application even when the network is not available. <span title=concept-serviceworker>Service worker</span>s are bit of scripts that can listen for network events (such as resource requests), manage content caches, and thus decide what content to display when a URL is requested. <span data-anolis-ref>URL</span> Putting it all together, <span title=concept-serviceworker>service worker</span>s give you a way to build applications that work offline.</p>

    <div class="example">
      <p>Some simple code to install a service worker and control the document from within the worker script:</p>

      <pre title="Installation from a page">// Document hosted at: http://videos.example.com/index.html
navigator.registerServiceWorker("/assets/v1/serviceworker.js", { scope: "/*" }).then(
  function(serviceWorker) {
    serviceWorker.postMessage("Howdy from your installing page.");
    // To use the serviceWorker immediately, you might call window.location.reload()
  },
  function(why) {
    console.error("Installing the worker failed!:", why);
  });</pre>

      <p>Listen to fetch event and cache necessary resources from the script:</p>
      <pre title="ServiceWorker script">// Service worker script hosted at: http://videos.example.com/assets/v1/serviceworker.js
this.addEventListener("install", function(e) {
  // Tell the system that this service worker can handle fetch events.
  e.services = ["fetch"];
});

this.addEventListener("fetch", function(e) {
  // DIY either offline! or online as fallback.

  // Create a cache of resources. Begins the process of fetching them.
  // URLs are relative to the service worker
  var shellResources = new Cache(
    base + "/assets/v1/base.css",
    base + "/assets/v1/app.js",
    base + "/assets/v1/logo.png",
    base + "/assets/v1/intro_video.webm",
  );

  // Add Cache to the global so it can be used later during onfetch
  this.caches.set("shell-v1", shellResources);

  // The coast is only clear when all the resources are ready.
  e.waitUntil(shellResources.ready());
});</pre>
    </div>

    <h2 id="conformance">Conformance</h2>

    <p>All diagrams, examples, and notes in this specification are
    non-normative, as are all sections explicitly marked non-normative.
    Everything else in this specification is normative.</p>

    <p>The key words "MUST", "MUST NOT", "REQUIRED", <!--"SHALL", "SHALL
    NOT",--> "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
    "OPTIONAL" in the normative parts of this specification are to be
    interpreted as described in RFC2119. For readability, these words do
    not appear in all uppercase letters in this specification.
    <span data-anolis-ref>RFC2119</span></p>

    <h3 id="dependencies">Dependencies</h3>
    <p>This specification relies on several underlying specifications.</p>

    <ul>
      <li><p>DOM Living Standard <span data-anolis-ref>DOM</span></p></li>
      <li><p>HTML Living Standard <span data-anolis-ref>HTML</span></p></li>
      <li><p>ECMAScript Langauage Specification <span data-anolis-ref>ECMASCRIPT</span></p></li>
      <li><p>Web IDL <span data-anolis-ref>WEBIDL</span></p></li>
    </ul>
    <p>It uses the typographic conventions from HTML. <span data-anolis-ref>HTML</span></p>

    <h3 id="extensibility">Extensibility</h3>

    <p>User agents, Working Groups, and other interested parties are
    <em>strongly encouraged</em> to discuss new features on a relevant public
    forum, preferably
    <a href="mailto:public-webapps@w3.org">public-webapps@w3.org</a>. If this
    is for some reason not possible prefix the extension in some way. E.g. if
    company Foo wants to add a proprietary method <code>bar()</code> it could
    be named <code>fooBar()</code> to prevent clashes with a potential
    non-proprietary method <code>bar()</code>.</p>

    <h2 id="terminology">Terminology</h2>

    <p>The <span data-anolis-spec=dom>Promise</span> interface provides asynchronous access to the result of an operation that is ongoing, has yet to start, or has completed, as defined in <span data-anolis-ref>DOM</span>.</p>

    <h2>Interfaces</h2>
    <p class='note'>This section normatively specifies the interfaces and the algorithms for the <span title=concept-serviceworker>service worker</span> infrastructure and lifecycle management. Relevant explainer is followed on the subsequent sections: Bootstrapping, Upgrade, <code>FetchEvent</code> and Caching.</p>

    <h3>Extensions to the <code>Navigator</code> object</h3>
    <pre class="idl">partial interface <span data-anolis-spec=html>Navigator</span> {
  <span data-anolis-spec=dom>Promise</span> <span title=serviceworker-navigator-registerserviceworker>registerServiceWorker</span>(DOMString <var>scriptURL</var>, optional <span>ServiceWorkerScopeOptions</span> <var>options</var>);
  <span data-anolis-spec=dom>Promise</span> <span title="">unregisterServiceWorker</span>(<span>ServiceWorker</span> <var>serviceWorker</var>);
          attribute <span data-anolis-spec=html>EventHandler</span> <span>onserviceworkerinstall</span>;
          attribute <span data-anolis-spec=html>EventHandler</span> <span>onserviceworkerreplaced</span>;
          attribute <span data-anolis-spec=html>EventHandler</span> <span>onserviceworkerreloadpage</span>;
};

dictionary <dfn title=ServiceWorkerScopeOptions>ServiceWorkerScopeOptions</dfn> {
  DOMString <span title="">scope</span> = "/*";
};</pre>

    <p>When the <dfn title=serviceworker-navigator-registerserviceworker><code>registerServiceWorker(scriptURL, options)</code></dfn> method is invoked, the user agent must run the following steps:</p>

    <ol>
      <li><p>Let <var>promise</var> be a newly-created <code><span data-anolis-spec=dom>Promise</span></code> object.</p></li>
      <li><p>Return <var>promise</var> and run the remaining steps asynchronously.</p></li>
      <li><p>If the request violates a policy decision (e.g. if the user agent is configured to not allow the page to start service workers), run these substeps and abort these steps:</p>
        <ol>
          <li><p>Let <var>error</var> be a new <span data-anolis-spec=html>DOMException</span> object whose type is "<span data-anolis-spec=html>SecurityError</span>".</p></li>
          <li><p>Reject <var>promise</var> with <var>error</var>.</p></li>
        </ol>
      </li>
      <li><p><span data-anolis-spec=html title="resolve a url">Resolve</span> the <var>scriptURL</var> argument.</p></li>
      <li><p>If this fails, run these substeps and abort these steps:</p>
        <ol>
          <li><p>Let <var>error</var> be a new <span data-anolis-spec=html>DOMException</span> object whose type is "<span data-anolis-spec=html>SyntaxError</span>".</p></li>
          <li><p>Reject <var>promise</var> with <var>error</var>.</p></li>
        </ol>
      </li>
      <li><p>Let <var>scriptURL</var> be the resulting <span data-anolis-spec=html>absolute URL</span> and <var>parsed scriptURL</var> be the resulting <span data-anolis-spec=html>parsed URL</span>.</p></li>
      <li><p>Let <var>options</var> be the value of the second argument, or null if the second argument was omitted.</p></li>
      <li><p>If the <span data-anolis-spec=html>scheme</span> component of <var>parsed scriptURL</var> is not "<code>data</code>", and the <span data-anolis-spec=html>origin</span> of <var>scriptURL</var> is not the <span data-anolis-spec=html title="same origin">same</span> as the <span data-anolis-spec=html>origin</span> specified by the <span data-anolis-spec=html>incumbent settings object</span>, run these substeps and abort these steps:</p>
        <ol>
          <li><p>Let <var>error</var> be a new <span data-anolis-spec=html>DOMException</span> object whose type is "<span data-anolis-spec=html>SecurityError</span>".</p></li>
          <li><p>Reject <var>promise</var> with <var>error</var>.</p></li>
        </ol>
      <p class=note>Thus, scripts must either be external files with the same scheme, host, and port as the original page, or <span data-anolis-spec=html title="data protocol"><code>data:</code> URLs</span>. For example, and an <code>https:</code> page couldn't start workers using scripts with http: URLs.</p></li>
      <li><p>Let <var>docs</var> be the <span data-anolis-spec=web-workers title="list of relevant document objects to add">list of relevant <code>Document</code> objects to add</span> given the <span data-anolis-spec=html>incumbent settings object</span>.</p></li>
      <li><p>Execute the following substeps atomically:</p>
        <ol>
          <li><p>Create a new <span>ServiceWorker</span> object, which will shortly be associated with a <span>ServiceWorkerGlobalScope</span> object. Let this <span>ServiceWorker</span> object be <var>worker</var>.</p></li>
          <li><p>Create a new <span data-anolis-spec=html-postmsg>MessagePort</span> object whose owner is the <span data-anolis-spec=html>incumbent settings object</span>. Let this be the <var>outside port</var>.</p></li>
          <li><p>Associate the <var>outside port</var> with <var>worker</var>.</p></li>
          <li><p>Let <var>worker global scope</var> be null.</p></li>
          <li><p>If there exists a <code><span>ServiceWorkerGlobalScope</span></code> object whose <span data-anolis-spec=web-workers>closing</span> flag is false, whose <code><span>location</span></code> attribute represents an <span data-anolis-spec=html>absolute URL</span> that is exactly equal to <var>scriptURL</var>, run these substeps:</p>
            <ol>
              <li><p>If <var>options</var> is not null and the <code><span>ServiceWorkerGlobalScope</span></code> object's <code><span>scope</span></code> attribute is not exactly equal to <var>scope</var> of <var>options</var>, set the <code><span>ServiceWorkerGlobalScope</span></code> object's <code><span>scope</span></code> attribute to <var>scope</var> of <var>options</var>.</p></li>
              <li><p>If <var>options</var> is null and the <code><span>ServiceWorkerGlobalScope</span></code> object's <code><span>scope</span></code> attribute is not the default scope, "<code>/*</code>", set the <code><span>ServiceWorkerGlobalScope</span></code> object's <code><span>scope</span></code> attribute to "<code>/*</code>".</p></li>
              <li><p>Let <var>worker global scope</var> be that <code><span>ServiceWorkerGlobalScope</span></code> object.</p></li>
            </ol>
          </li>
          <li><p>If <var>worker global scope</var> is not null, but the user agent has been configured to disallow communication between the worker represented by the <var>worker global scope</var> and the <span data-anolis-spec=html title=script-0>scripts</span> whose <span data-anolis-spec=html>settings object</span>s are the <span data-anolis-spec=html>incumbent settings object</span>, then set <var>worker global scope</var> to null.</p></li>
          <li><p>If <var>worker global scope</var> is not null, then run these steps:</p>
            <ol>
              <li><p>If <var>worker global scope</var>'s <code><span data-anolis-spec=web-workers>location</span></code> attribute represents an <span data-anolis-spec=html>absolute URL</span> that is not exactly equal to <var>scriptURL</var>, run these substeps and abort these steps:</p>
                <ol>
                  <li><p>Let <var>error</var> be a new <span data-anolis-spec=html>DOMException</span> object whose type is "<span data-anolis-spec=html>URLMismatchError</span>".</p></li>
                  <li><p>Reject <var>promise</var> with <var>error</var>.</p></li>
                </ol>
              </li>
              <li><p>Associate <var>worker</var> with <var>worker global scope</var>.</p></li>
              <li><p>Let <var>settings object</var> be the <span data-anolis-spec=html>script settings object</span> whose <span data-anolis-spec=html>global object</span> is <var>worker global scope</var>.</p></li>
              <li><p>Create a new <span data-anolis-spec=html-postmsg>MessagePort</span> object whose owner is <var>settings object</var>. Let this be <var>inside port</var>.</p></li>
              <li><p><span data-anolis-spec=html-postmsg>Entangle</span> <var>outside port</var> and <var>inside port</var>.</p></li>
              <li><p>Create a <span data-anolis-spec=html>trusted event</span> that uses the <code><span data-anolis-spec=html-postmsg>MessageEvent</span></code> interface, with the name <code>install</code>, which does not bubble, is not cancelable, has no default action, has a <code><span>services</span></code> attribute whose value is initialized to an empty array, has a <code><span data-anolis-spec=html-postmsg>data</span></code> attribute whose value is initialized to the empty string, has a <code><span data-anolis-spec=html-postmsg>ports</span></code> attribute whose value is initialized to a <span data-anolis-spec=html>read only</span> array containing only the newly created port, and has a <code><span data-anolis-spec=html-postmsg>source</span></code> attribute whose value is initialized to the newly created port, and <span data-anolis-spec=html>queue a task</span> to <span data-anolis-spec=html>dispatch</span> the event at <var>worker global scope</var>.</p></li>
              <li><p><span data-anolis-spec=web-workers title=add-a-document-to-the-worker-s-documents>Add to <var>worker global scope</var>'s list of the worker's <code>Document</code>s</span> the <code><span data-anolis-spec=html>Document</span></code> objects in <var>docs</var>.</p></li>
              <li><p>If the <span data-anolis-spec=html>global object</span> specified by the <span data-anolis-spec=html>incumbent settings object</span> is a <code><span data-anolis-spec=web-workers>WorkerGlobalScope</span></code> object, add <var>worker global scope</var> to the list of <span data-anolis-spec=web-workers title=the-worker-s-workers>the worker's workers</span> of the <code><span data-anolis-spec=web-workers>WorkerGlobalScope</span></code> object that is the <span data-anolis-spec=html>global object</span> specified by the <span data-anolis-spec=html>incumbent settings object</span> .</p></li>
              <li><p>Return <var>worker</var> and abort all these steps.</p></li>
            </ol>
          </li>
          <li><p>Create a new <code><span>ServiceWorkerGlobalScope</span></code> object. Let <var>worker global scope</var> be this new object.</p>
            <p class=critical>When there exists aother active service worker which covers the exactly same <code><span>scope</span></code> with different <code><span>scriptURL</span></code>, a new service worker is to be created by this algorithm. As the newly created worker would be effective from the next page load, that currently effective worker should not be terminated right away. An algorithm to sweep the unbound service workers should be added. Sweeping must not be conducted unless otherwise the list of <span data-anolis-spec=web-workers title=the-worker-s-documents>the worker's <code><span>Document</span></code>s</span> is empty. (See <span>Last-registration wins</span>.)</p>
          </li>
          <li><p><span data-anolis-spec=web-workers>Set up a worker script settings object</span> with <var>worker global scope</var> and <var>scriptURL</var>, and let <var>settings object</var> be the result.</p></li>
          <li><p>Associate <var>worker</var> with <var>worker global scope</var>.</p></li>



          <li><p>If <var>options</var> is not null, set the <code><span>scope</span></code> attribute of <var>worker global scope</var> to <var>scope</var> of <var>options</var>; Otherwise, set the <code><span>scope</span></code> attribute of <var>worker global scope</var> to the default scope, "<code>/*</code>".</p></li>
          <li><p>Create a new <code><span data-anolis-spec=html-postmsg>MessagePort</span></code> object whose <span data-anolis-spec=html-postmsg>owner</span> is <var>settings object</var>. Let <var>inside port</var> be this new object.</p></li>
          <li><p><span data-anolis-spec=html-postmsg>Entangle</span> <var>outside port</var> and <var>inside port</var>.</p></li>
        </ol>
      </li>
      <li><p>Let <var title="">serviceWorker</var> be <var>worker</var>.</p></li>
      <li><p>Resolve <var>promise</var> with <var title="">serviceWorker</var> and perform the remaining steps asynchronously.</p></li>
      <li><p>Create a <span data-anolis-spec=html>trusted event</span> that uses the <code><span data-anolis-spec=html-postmsg>MessageEvent</span></code> interface, with the name <code>install</code>, which does not bubble, is not cancelable, has no default action, has a <code><span>services</span></code> attribute whose value is initialized to an empty array, has a <code><span data-anolis-spec=html-postmsg>data</span></code> attribute whose value is initialized to the empty string, has a <code><span data-anolis-spec=html-postmsg>ports</span></code> attribute whose value is initialized to a <span data-anolis-spec=html>read only</span> array containing only the newly created port, and has a <code><span data-anolis-spec=html-postmsg>source</span></code> attribute whose value is initialized to the newly created port, and <span data-anolis-spec=html>queue a task</span> to <span data-anolis-spec=html>dispatch</span> the event at <var>worker global scope</var>.</p></li>
      <li><p><span data-anolis-spec=web-workers title=add-a-document-to-the-worker-s-documents>Add to <var>worker global scope</var>'s list of the worker's <code>Document</code>s</span> the <code><span data-anolis-spec=html>Document</span></code> objects in <var>docs</var>.</p></li>
      <li><p>If the <span data-anolis-spec=html>global object</span> specified by the <span data-anolis-spec=html>incumbent settings object</span> is a <code><span data-anolis-spec=web-workers>WorkerGlobalScope</span></code> object, add <var>worker global scope</var> to the list of <span data-anolis-spec=web-workers title=the-worker-s-workers>the worker's workers</span> of the <code><span data-anolis-spec=web-workers>WorkerGlobalScope</span></code> object that is the <span data-anolis-spec=html>global object</span> specified by the <span data-anolis-spec=html>incumbent settings object</span> .</p></li>
      <li><p><span data-anolis-spec=web-workers>Run a worker</span> for the script with <span data-anolis-spec=url>URL</span> <var>scriptURL</var> and the <span data-anolis-spec=html>script settings object</span> <var>settings object</var>.</p></li>
    </ol>
    <p>The <span data-anolis-spec=html>task source</span> for the tasks mentioned above is the <span data-anolis-spec=html title=dom-manipulation-task-source>DOM manipulation task source</span>.</p>

    <h3>The <code>ServiceWorker</code> interface</h3>
    <pre class="idl">
[NoInterfaceObject]
interface <dfn>ServiceWorker</dfn> : <span data-anolis-spec=dom>EventTarget</span> {
  void <span title="">postMessage</span>(any <var>message</var>, optional sequence&lt;Transferable&gt; <var>transfer</var>);
          attribute <span data-anolis-spec=html>EventHandler</span> <span>onmessage</span>;
};
<span>ServiceWorker</span> implements <span data-anolis-spec=web-workers title=abstractworker>AbstractWorker</span>;</pre>

    <p><code><span>ServiceWorker</span></code> objects act as if they had an implicit <span data-anolis-spec=html-postmsg>MessagePort</span> associated with them. This port is part of a channel that is set up when the worker is registered, but it is not exposed. It represents the <span data-anolis-spec=html-postmsg>MessagePort</span> for communicating with the service worker. This object must never be garbage collected before the <code><span>ServiceWorker</span></code> object.</p>

    <p>All messages received by that port must immediately be retargeted at the <code><span>ServiceWorker</span></code> object.</p>

    <p>The <code>postMessage()</code> method on <code><span>ServiceWorker</span></code> objects must act as if, when invoked, it immediately invoked <span data-anolis-spec=html-postmsg title=dom-messageport-postmessage>the method of the same name</span> on the port, with the same arguments, and returned the same return value.</p>

    <p>The following are the <span data-anolis-spec=html>event handlers</span> (and their corresponding <span data-anolis-spec=html>event handler event type</span>s) that must be supported, as <span data-anolis-spec=html>event handler IDL attribute</span>s, by objects implementing the <code><span>ServiceWorker</span></code> interface:</p>

    <table>
      <thead>
        <tr>
          <th><span data-anolis-spec=html title="event handlers">event handler</span></th>
          <th><span data-anolis-spec=html>event handler event type</span></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><dfn title="handler-serviceworker-onmessage"><code>onmessage</code></dfn></td>
          <td><code title="event-serviceworker-message">message</code></td>
        </tr>
      </tbody>
    </table>

    <h3>The <code>ServiceWorkerGlobalScope</code> interface</h3>
    <pre class="idl">
[Global]
interface <dfn>ServiceWorkerGlobalScope</dfn> : <span data-anolis-spec=web-workers>WorkerGlobalScope</span> {
  getter <span data-anolis-spec=html>WindowProxy</span>[] windows();
  <span data-anolis-spec=dom>Promise</span> <span title="">fetch</span>((<span>Request</span> or <span data-anolis-spec=url>URL</span> or DOMString or any) <var>request</var>);
  [Unforgeable] readonly attribute DOMString scope;
          attribute <span>CacheList</span> caches;
          attribute any version;
          attribute <span data-anolis-spec=html>EventHandler</span> <span>oninstall</span>;
          attribute <span data-anolis-spec=html>EventHandler</span> <span>onactivate</span>;
          attribute <span data-anolis-spec=html>EventHandler</span> <span>onfetch</span>;
          attribute <span data-anolis-spec=html>EventHandler</span> <span>onbeforeevicted</span>;
          attribute <span data-anolis-spec=html>EventHandler</span> <span>onevicted</span>;
  // close() method inherited from WorkerGlobalScope is not exposed.
};</pre>

    <p>The <code><span>ServiceWorkerGlobalScope</span></code> interface must only be <span data-anolis-spec=html>exposed to JavaScript</span> if the <span data-anolis-spec=html>JavaScript global environment</span> is a <span>service worker environment</span>.</p>

    <p class="note">Todo: the definition of the <span>service worker environment</span> should be placed in the <span data-anolis-spec=html>processing model</span> section of HTML specification.</p>

    <p>Service workers receive message ports through <code><span>install</span></code> events on their <code><span>ServiceWorkerGlobalScope</span></code> object for each registration.</p>

    <dl class=domintro>
      <dt><code>this.windows</code></dt>
      <dd>Returns the array of the the <code><span data-anolis-spec=html>Window</span></code> object's <code><span data-anolis-spec=html>browsing context</span></code>'s <code><span data-anolis-spec=html>WindowProxy</span></code> object that the <span><code>ServiceWorkerGlobalScope</code></span> is bound to.</dd>
      <dt><code>this.fetch()</code></dt>
      <dd>Returns the <code>Promise</code> object that represents the <code>Response</code> object of the <span data-anolis-spec=fetch>fetch</span>ed resource.</dd>
      <dt><code>this.scope</code></dt>
      <dd>Returns the <code>scope</code> string that the worker listens to.</dd>
      <dt><code>this.caches</code></dt>
      <dd>Returns the current <code>CacheList</code> object.</dd>
      <dt><code>this.version</code></dt>
      <dd>Returns the version that has been set by the worker. It is <span data-anolis-spec=html>structured clone</span>able.</dd>
    </dl>

    <p class="note">The <code>version</code> attribute is used to communicate to newer versions what they are replaceing (see the <code>previousVersion</code> attribute of the <code>InstallEvent</code> interface.)</p>

    <p>The following are the <span data-anolis-spec=html>event handlers</span> (and their corresponding <span data-anolis-spec=html>event handler event type</span>s) that must be supported, as <span data-anolis-spec=html>event handler IDL attribute</span>s, by objects implementing the <code><span>ServiceWorkerGlobalScope</span></code> interface:</p>

    <table>
      <thead>
        <tr>
          <th><span data-anolis-spec=html title="event handlers">event handler</span></th>
          <th><span data-anolis-spec=html>event handler event type</span></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><dfn title="handler-serviceworker-oninstall"><code>oninstall</code></dfn></td>
          <td><code title="event-serviceworker-install">install</code></td>
        </tr>
        <tr>
          <td><dfn title="handler-serviceworker-onactivate"><code>onactivate</code></dfn></td>
          <td><code title="event-serviceworker-activate">activate</code></td>
        </tr>
        <tr>
          <td><dfn title="handler-serviceworker-onfetch"><code>onfetch</code></dfn></td>
          <td><code title="event-serviceworker-fetch">fetch</code></td>
        </tr>
        <tr>
          <td><dfn title="handler-serviceworker-onbeforeevicted"><code>onbeforeevicted</code></dfn></td>
          <td><code title="event-serviceworker-beforeevicted">beforeevicted</code></td>
        </tr>
        <tr>
          <td><dfn title="handler-serviceworker-onevicted"><code>onevicted</code></dfn></td>
          <td><code title="event-serviceworker-evicted">evicted</code></td>
        </tr>
      </tbody>
    </table>

    <h3>The <code>InstallEvent</code> interface</h3>
    <pre class="idl">
interface <dfn>InstallEvent</dfn> : <span>InstallPhaseEvent</span> {
  void <span>replace</span>();
  <span data-anolis-spec=dom>Promise</span> <span>reloadAll</span>();
          attribute <span data-anolis-spec=html-postmsg>MessagePort</span> previous;
          attribute DOMString[] services;
};

interface <dfn>InstallPhaseEvent</dfn> : <span data-anolis-spec=dom>Event</span> {
  <span data-anolis-spec=dom>Promise</span> <span>waitUntil</span>(<span data-anolis-spec=dom>Promise</span> <var>f</var>);
          attribute any previousVersion;
};</pre>

    <h3>The <code>ReloadPageEvent</code> interface</h3>
    <pre class="idl">
interface <dfn>ReloadPageEvent</dfn> : <span data-anolis-spec=dom>Event</span> {
  void <span>waitUntil</span>(<span data-anolis-spec=dom>Promise</span> f);
};</pre>

    <h3>The <code>FetchEvent</code> interface</h3>
    <pre class="idl">
[Constructor]
interface <dfn>FetchEvent</dfn> : <span data-anolis-spec=dom>Event</span> {
  void <span>respondWith</span>((<span data-anolis-spec=dom>Promise</span> or <span>Response</span>) <var>r</var>);
  <span data-anolis-spec=dom>Promise</span> <span>forwardTo</span>((<span data-anolis-spec=url>URL</span> or [EnsureUTF16] DOMString) <var>url</var>);
  readonly attribute <span>Request</span> request;
  readonly attribute <span>RequestType</span> type;
  readonly attribute <span data-anolis-spec=html>WindowProxy</span> window;
  readonly attribute boolean isTopLevel;
  readonly attribute boolean isReload;
};

enum <dfn>RequestType</dfn> {
    "navigate",
    "fetch"
};</pre>

    <h3>The <code>Request</code> interface</h3>
    <pre class="idl">
// <a href="#request">request</a>
[Constructor(optional <span>RequestInit</span> init)]
interface <dfn>Request</dfn> {
  readonly attribute unsigned long timeout;
  readonly attribute (<span data-anolis-spec=url>URL</span> or [EnsureUTF16] DOMString) url;
  readonly attribute DOMString encoding;
  readonly attribute ByteString method;
  readonly attribute (<span data-anolis-spec=url>URL</span> or [EnsureUTF16] DOMString) origin;
  readonly attribute <span>Mode</span> mode;
  readonly attribute boolean synchronous;
  readonly attribute unsigned long redirectCount;
  readonly attribute boolean forcePreflight;
  readonly attribute boolean omitCredentials;
  readonly attribute (<span data-anolis-spec=url>URL</span> or [EnsureUTF16] DOMString) referrer;
  ByteString? <span>getHeader</span>(ByteString <var>header</var>);
          attribute sequence&lt;<span>Header</span>&gt; headers;
  readonly attribute any body;
};

dictionary <dfn>RequestInit</dfn> {
  unsigned long timeout;
  (<span data-anolis-spec=url>URL</span> or [EnsureUTF16] DOMString) url;
  DOMString encoding;
  ByteString method = "GET";
  boolean synchronous = false;
  unsigned long redirectCount = 0;
  boolean forcePreflight = false;
  boolean omitCredentials = false;
  (<span data-anolis-spec=url>URL</span> or [EnsureUTF16] DOMString) referrer;
  sequence&lt;<span>Header</span>&gt; headers;
  any body = null;
};

enum <dfn>Mode</dfn> {
  "same origin",
  "tainted x-origin",
  "CORS"
};

dictionary <dfn>Header</dfn> {
  ByteString name;
  ByteString value;
};</pre>

    <h3>The <code>Response</code> interface</h3>
    <pre class="idl">
[Constructor]
interface <dfn>Response</dfn> {
};

[Constructor(optional <span>SameOriginResponseInit</span> <var>responseInitDict</var>)]
interface <dfn>SameOriginResponse</dfn> : <span>Response</span> {
  void <span>setHeader</span>(ByteString <var>name</var>, ByteString <var>value</var>);
  ByteString? <span>getHeader</span>(ByteString <var>header</var>);
          attribute sequence&lt;<span>Header</span>&gt; headers;
          attribute unsigned short statusCode;
          attribute ByteString statusText;
          attribute DOMString encoding;
          attribute ByteString method;
          attribute any body;
};

dictionary <dfn>SameOriginResponseInit</dfn> {
  unsigned short statusCode = 200;
  ByteString statusText = "OK";
  DOMString encoding;
  ByteString method;
  sequence&lt;<span>Header</span>&gt; headers;
  any body;
};

interface <dfn>CrossOriginResponse</dfn> : <span>Response</span> {
};</pre>

    <h3>The <code>Cache</code> interface</h3>
    <pre class="idl">
[Constructor((URL or [EnsureUTF16] DOMString)... urls)]
interface <dfn>Cache</dfn> {
  <span data-anolis-spec=dom>Promise</span> match((<span data-anolis-spec=url>URL</span> or [EnsureUTF16] DOMString) <var>name</var>);
  <span data-anolis-spec=dom>Promise</span> add((<span data-anolis-spec=url>URL</span> or [EnsureUTF16] DOMString)... <var>responses</var>);
  <span data-anolis-spec=dom>Promise</span> addResponse((<span data-anolis-spec=url>URL</span> or [EnsureUTF16] DOMString) <var>url</var>, <span>Response</span> <var>response</var>);
  <span data-anolis-spec=dom>Promise</span> remove((<span data-anolis-spec=url>URL</span> or [EnsureUTF16] DOMString)... <var>responses</var>);
  <span data-anolis-spec=dom>Promise</span> update((<span data-anolis-spec=url>URL</span> or [EnsureUTF16] DOMString)... <var>urls</var>);
  <span data-anolis-spec=dom>Promise</span> ready();
        attribute <span>AsyncMap</span> items;
};

[<span data-anolis-spec=webidl>MapClass</span>(DOMString, <span data-anolis-spec=dom>Promise</span>)]
interface <dfn>AsyncMap</dfn> {
  <span data-anolis-spec=dom>Promise</span> items();
  <span data-anolis-spec=dom>Promise</span> keys();
  <span data-anolis-spec=dom>Promise</span> values();
};

[<span data-anolis-spec=webidl>MapClass</span>(DOMString, <span>Cache</span>)]
interface <dfn>CacheList</dfn> {
  (<span data-anolis-spec=dom>Promise</span> or <span>Response</span>) match(DOMString name, (<span data-anolis-spec=url>URL</span> or [EnsureUTF16] DOMString) url);
};</pre>

    <h3 id="events">Events summary</h3>

    <p><em>This section is non-normative.</em></p>

    <p>The following events are dispatched on <code>ServiceWorkerGlobalScope</code> object:</p>

    <table>
      <thead>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Dispatched when&hellip;</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><dfn title=event-serviceworker-install><code>install</code></dfn></td>
          <td><code>InstallEvent</code></td>
          <td>A worker is downloaded and being setup to handle events (navigations, alerts, etc.)</td>
        </tr>
      </tbody>
    </table>

    <h2>Bootstrap with a service worker</h2>
    <p>A <span title=concept-serviceworker>service worker</span> MUST be installed either by invoking the <span title=serviceworker-navigator-registerserviceworker><code>registerServiceWorker()</code></span> method within web pages or by setting the member <em>serviceworker</em> of the manifest to be the URL of the <span title=concept-serviceworker>service worker</span>.</p>

    <h3>The <span title=serviceworker-navigator-registerserviceworker><code>registerServiceWorker()</code></span> method</h3>
    <p><span title=concept-serviceworker>Service worker</span>s MAY be installed by web pages. A user MUST visit a web page or web application for the process to start.</p>
    <div class="example">
      <pre title="Installation">
// Document hosted at: http://videos.example.com/index.html
navigator.registerServiceWorker("/assets/v1/ctrl.js", { scope: "/*"}).then(
  function(serviceWorker) {
    console.log("success!");
    serviceWorker.postMessage("Howdy from your installing page.");
    // To use the serviceWorker immediately, you might call window.location.reload()
  },
  function(why) {
    console.error("Installing the worker failed!:", why);
  });</pre>
    </div>

    <p>The example shows the <span title=concept-serviceworker>service worker</span> hosted at <code>/assets/v1/ctrl.js</code> is installed by the web page hosted at <code>http://videos.example.com/index.html</code>.</p>
    <div class="example">
      <pre title="ServiceWorker script serving onfetch event">
// Service worker script hosted at: /assets/v1/ctrl.js
this.version = 1;

var base = "http://videos.example.com";
var inventory = new URL("/services/inventory/data.json", base);

this.addEventListener("install", function(e) {
  // Tell the system that this service worker can handle fetch events.
  e.services = ["fetch"];
});

this.addEventListener("fetch", function(e) {
  var url = e.request.url;
  console.log(url);
  if (url.toString() == inventory.toString()) {
    e.respondWith(new SameOriginResponse({
      statusCode: 200,
      body: JSON.stringify({
        videos: { /* ... */ }
      })
    }));
  }
});
        </pre>
    </div>
    <p>
    Once the <code>ctrl.js</code> in the example is successfully installed, the "success!"" message will be sent to the console and, crucially, the next time the user visits <code>index.html</code> or any other page located at <code>http://videos.example.com/</code>, <code>ctrl.js</code> will be consulted about what to do and what content to load even if the device has no Internet connection. On pages that are <em>controlled</em> in this way, other resources (like images in the document body) are also requested first from <code>ctrl.js</code> before the normal browser cache is consulted for them.</p>

    <h3>The member <em><code>serviceworker</code></em> of the manifest</h3>
    <p class='critical'>This section remains unspecified as neither the architecture has been clarified nor has it been aligned with the standards track <a class='external' href='http://w3c.github.io/manifest/'>manifest</a> specification.</p>

    <h3><em>Controlled</em> and <em>uncontrolled</em> documents</h3>
    <p>The first time <code>http://videos.example.com/index.html</code> is loaded, all the resources it requests will come from the network. That means that even if the browser runs the install snippet for <code>ctrl.js</code>, <span data-anolis-spec=fetch>fetch</span>es it, and finishes installing it before it begins <span data-anolis-spec=fetch>fetch</span>ing logo.png, the new <span title=concept-serviceworker>service worker</span> script would not be consulted about loading logo.png. This is down to the following rule of <span title=concept-serviceworker>service worker</span>s:</p>
    <ul>
      <li>Documents live out their whole lives using the service worker they start with.</li>
    </ul>
    <p>This means that if a document starts life without a <span title=concept-serviceworker>service worker</span>, even if one is installed for a matching bit of URL space, it would not suddenly get a <span title=concept-serviceworker>service worker</span> later in life. Same goes for documents that are loaded with a <span title=concept-serviceworker>service worker</span> which might later call <code>unregisterServiceWorker()</code>. Put another way, <span title=serviceworker-navigator-registerserviceworker><code>registerServiceWorker()</code></span> and <code>unregisterServiceWorker()</code> only affect the next document(s).</p>


    <h3>Longest-prefix matching</h3>
    <div class="example">
      <pre title="Longest-prefix matching [ex 1]">
&lt;!DOCTYPE html&gt;
&lt;!-- http://www.example.com/foo.html --&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script&gt;
      navigator.registerServiceWorker("/fooServiceWorker.js", { scope: "/foo*"});
    &lt;/script&gt;
  &lt;/head&gt;
&lt;/html&gt;</pre>
      <pre title="Longest-prefix matching [ex 2]">
&lt;!DOCTYPE html&gt;
&lt;!-- http://www.example.com/foo/bar.html --&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script&gt;
      navigator.registerServiceWorker("/foo/barServiceWorker.js", { scope: "/foo/bar*" });
    &lt;/script&gt;
  &lt;/head&gt;
&lt;/html&gt;</pre>
    </div>
    <p>To break what might otherwise be ties when matching URLs, navigations are mapped to <span title=concept-serviceworker>service worker</span>s by longest-prefix-match. Note that the <code>*</code> can only occur at the end of a matching rule, so attempts to register <code>/foo/*/bar</code> or <code>*bar</code> will <span data-anolis-spec=webidl>throw</span> exceptions. Similarly, registering a scope that includes a <code>"?"</code> or <code>"#"</code> will also <span data-anolis-spec=webidl>throw</span>s exceptions.</p>
    <p>In the above example with registrations for <code>/foo*</code> and <code>/foo/bar*</code>, the following matches would be made when navigating to the following URLs under <code>http://www.example.com</code>:</p>
    <table border="1">
      <tr>
        <th>Scope (Pattern)</th>
        <th>URL</th>
      </tr>
      <tr>
        <td><code>/foo</code></td>
        <td><code>/fooServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foo?blarg</code></td>
        <td><code>/fooServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foo/</code></td>
        <td><code>/fooServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foo/thinger.html</code></td>
        <td><code>/fooServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foobar.html</code></td>
        <td><code>/fooServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foo/other/thinger.html</code></td>
        <td><code>/fooServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foo/bar</code></td>
        <td><code>/foo/barServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foo/bar/</code></td>
        <td><code>/foo/barServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foo/bar/thinger.html</code></td>
        <td><code>/foo/barServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/foo/bar/baz/thinger.html</code></td>
        <td><code>/foo/barServiceWorker.js</code></td>
      </tr>
      <tr>
        <td><code>/index.html</code></td>
        <td><code>&lt;fallback to native&gt;</code></td>
      </tr>
      <tr>
        <td><code>/whatevs/index.html</code></td>
        <td><code>&lt;fallback to native&gt;</code></td>
      </tr>
    </table>
    <p><code>&lt;fallback to native&gt;</code> is the browser's built-in behavior for fetching resources - the thing the Fetch Service defers to when it does not handle a fetch with <code>e.respondWith()</code>.</p>
    <p class='note'>If <code>e.respondWith()</code> is not called when handling a connection in <code>/foo/barServiceWorker.js</code>, it does not cascade to <code>/fooServiceWorker.js</code>, it falls back to the browser's built-in network behavior.</p>

    <h3><dfn>Last-registration wins</dfn></h3>
    <p>The registration system is also last-registration-wins. That means if two pages on <code>www.example.com</code> set a registration to control <code>/*</code>, the one a user visits second (assuming the first does not interfere) will be installed and over-write the previous registration.</p>

    <p>This makes sense because registration is the same as replacement. That is to say, if you have content that wants to replace the existing <span title=concept-serviceworker>service worker</span> with one at a different URL (perhaps a heavy-handed form of "new version"), registering the new URL is the way that you indicate that the old registration is no longer the preferred one.</p>

    <h3>Cross-origin limitation</h3>
    <p>One of the concerns that major applications hit is "how do I host things from a CDN?" By definition, these are servers in other places, often on other domains, that your content references. Can <span title=concept-serviceworker>service worker</span>s be hosted on CDNs? No, this is not allowed since <span title=concept-serviceworker>service worker</span>s can create the possibility of an XSS vulnerability, etc.</p>

    <p>But they can include resources (via <code>importScripts()</code>) that are.</p>

    <h2>Lifecycle of a service worker</h2>
    <p>The browser might unceremoniously kill your <span title=concept-serviceworker>service worker</span> if it is idle, or even stop it mid-work and re-issue the request to a different instance of the worker. There are no guarantees about how long a <span title=concept-serviceworker>service worker</span> will run. <span title=concept-serviceworker>service worker</span>s should be written to avoid holding global state. This cannot be stressed enough: write your workers as though they will die after every request.</p>
    <p>Also remember that <span title=concept-serviceworker>service worker</span>s are shared resources. A single worker might be servicing requests from multiple tabs or documents. Never assume that only one document is talking to a given <span title=concept-serviceworker>service worker</span>. If you care about where a request is coming from or going to, use the <code>.window</code> property of the <code>onfetch</code> event; but do not create state that you care about without serializing it somewhere like IndexedDB.</p>


    <h2>Upgrade with a new version</h2>

    <h3>Wait-for-restart</h3>
    <p>The default policy is that this new tab will be controlled by v1. This is done to prevent the crazy-town scenario of multiple <span title=concept-serviceworker>service worker</span> versions running at the same time, possibly creating conflicts for IndexedDB schemas, content caches, and the like. Yes, there is a small window during <code>oninstall</code> when v2 will be running at the same time as v1, but they would not both be serving content. The advice then is: do not do irreversible things during oninstall. It is a good place to get a jump on populating caches (with unique names if the new content is reliant on the new <span title=concept-serviceworker>service worker</span>), but a bad place to do things like schema and model upgrades for your application.</p>

    <p>The alternative scenario is one in which the new version of your <span title=concept-serviceworker>service worker</span> is discovered and installed and no documents are running against v1. This could happen because:</p>

    <ul>
      <li>v1 was installed by a page that was loaded "naked", but which was never reloaded so as to start under the <span title=concept-serviceworker>service worker</span>.</li>
      <li>The browser fetched an update of it is own volition. It is allowed to do that!</li>
      <li>Between the time <code>oninstall</code> started for the v2 <span title=concept-serviceworker>service worker</span> and when <code>waitUntil()</code> was finally satisfied, all of the application's windows were closed.</li>
    </ul>

    <p>When this happens, v2 instantly becomes the active <span title=concept-serviceworker>service worker</span>, so the next time you navigate to a URL controlled by the registration, v2 would get first crack at it.</p>

    <p>Indeed, v2 will become the active <span title=concept-serviceworker>service worker</span> just as soon as all v1 documents are closed.</p>

    <p>When v2 does become the active <span title=concept-serviceworker>service worker</span>, another event - <code>onactivate</code> - is sent to v2. This happens before any fetches are dispatched. This is the ideal time to upgrade database schemas and the like, but be careful not to do too much work. Applications will be blocked from loading while <code>onactivate</code> is being serviced (including any extensions asked for via <code>e.waitUntil()</code>, which is also available to <code>onactivate</code> handlers). Treat <code>onactivate</code> as a time to stake your claim as the new version but beware doing more than that lest you make your app unavailable!</p>

    <h3>Replacement</h3>
    <p>An alternative policy is available for the daring: a new <span title=concept-serviceworker>service worker</span> can choose to cut-in and replace an existing one. And before you ask, yes, this does break the first rule. But not much.</p>

    <p>To replace an existing <span title=concept-serviceworker>service worker</span>, use the <code>.replace()</code> method of the <code>oninstall</code> event during the event dispatch. In fact, you can even call <code>.replace()</code> on the very first install of a <span title=concept-serviceworker>service worker</span>, which will now make your <span title=concept-serviceworker>service worker</span> the proud owner of all windows/tabs whose URLs match the registration origin and scope including the page that registered it.</p>

    <p>Here is an example: we'll compare the versions to ensure that they are not so far apart that stepping in would break things; leaving the old <span title=concept-serviceworker>service worker</span> in place if the version skew is too great and taking over if it is a difference our new version is confident it can handle. Consider v1.3 vs. v1.0:</p>

    <div class="example">
      <pre title="Replacement">
// caching.js
this.version = 1.3;

var assetBase = "/assets/v" + parseInt(this.version) + "/";
var shellCacheName = "shell-v" + parseInt(this.version);
var contentCacheName = "content";

this.addEventListener("install", function(e) {
  e.services = ["fetch"];

  // Create a cache of resources. Begins the process of fetching them.
  var shellResources = new Cache(
    assetBase + "/base.css",
    assetBase + "/app.js",
    assetBase + "/logo.png",
    assetBase + "/intro_video.webm",
  );

  // Add Cache to the global so it can be used later during onfetch
  this.caches.set(shellCacheName, shellResources);

  // Prepare an additional cache that we can add items to later
  if (!this.caches.has(contentCacheName)) {
    this.caches.set(contentCacheName, new Cache());
  }

  // The coast is only clear when all the resources are ready.
  e.waitUntil(shellResources.ready());

  // If and only if we're less than one major version ahead, cut-in and start
  // serving resources.
  if (parseInt(e.previousVersion) == parseInt(this.version)) {
    // Note: replacement won't happen until the Promise passed to
    // e.waitUntil resolves
    e.replace();
  }
});

// ...onfetch, etc...</pre>
    </div>
    <p>The <code>previousVersion</code> field of the event is filled in using a structured clone of the global version property set by the last execution of the previous <span title=concept-serviceworker>service worker</span>. It is a good idea both to always set a version and, sort of obviously, not to make it something that can't be cloned or which varies.</p>

    <p>What of the old <span title=concept-serviceworker>service worker</span>? What happens to it?</p>

    <p>The replacing <span title=concept-serviceworker>service worker</span> can send a message to the old <span title=concept-serviceworker>service worker</span> in <code>oninstalled</code> using <code>e.previous.postMessage()</code>. This can blossom into a bi-directional discussion if both sides have registered <code>onmessage</code> handlers, but that is out of the scope of this document for now.</p>

    <h2>Offline-first resource handling</h2>

    <h3><code>FetchEvent</code> handling</h3>
    <p><span title=concept-serviceworker>service worker</span>s, once installed, can choose to handle resource loading. Before going to the network to <span data-anolis-spec=fetch>fetch</span> a document that matches the service worker's scope, the worker is consulted, including when <span data-anolis-spec=fetch>fetch</span>ing the document payload itself.

    Here is an example of a <span title=concept-serviceworker>service worker</span> that only handles a single resource (<code>/services/inventory/data.json</code>) but which logs out requests for all resources it is consulted for:</p>

    <div class="example">
      <pre title="onfetch handling in a service worker">
// hosted at: /assets/v1/ctrl.js
this.version = 1;

var base = "http://videos.example.com";
var inventory = new URL("/services/inventory/data.json", base);

this.addEventListener("install", function(e) {
  // Tell the system that this service worker can handle fetch events.
  e.services = ["fetch"];
});

this.addEventListener("fetch", function(e) {
  var url = e.request.url;
  console.log(url);
  if (url.toString() == inventory.toString()) {
    e.respondWith(new SameOriginResponse({
      statusCode: 200,
      body: JSON.stringify({
        videos: { /* ... */ }
      })
    }));
  }
});</pre>
    </div>
    <p>The contents of all but the inventory will be handled by the normal browser resource fetching system because the onfetch event handler did not call <code>respondWith</code> when invoked with their requests. The first time the app is loaded (before the <span title=concept-serviceworker>service worker</span> is installed), <code>data.json</code> will also be fetched from the network. Thereafter it will be computed by the <span title=concept-serviceworker>service worker</span> instead. The important thing to remember here is that normal resource loading is the fallback behavior for fetch events.</p>
    <p>When combined with access to IndexedDB and a new form of <code>Cache</code>, the ability to respond with arbitrary content is incredibly powerful. Since installed <span title=concept-serviceworker>service worker</span>s are invoked even when offline, <span title=concept-serviceworker>service worker</span>s enable apps that are "offline by default" once installed.</p>

    <h3>Navigation vs Fetch</h3>
    <p>Description</p>

    <h3>Fallback rule</h3>
    <p>Description</p>

    <h3>Redirects</h3>
    <p>Description</p>

    <h3>Cross-origin resources</h3>
    <p>Description</p>

    <h2>Caching</h2>
    <div class="example">
      <pre title="Cache control in service worker script">
// Service worker script hosted at: /assets/v1/caching.js
this.version = 1;

var base = "http://videos.example.com";
this.addEventListener("install", function(e) {
  e.services = ["fetch"];

  // Create a cache of resources. Begins the process of fetching them.
  // URLs are relative to the service worker
  var shellResources = new Cache(
    base + "/assets/v1/base.css",
    base + "/assets/v1/app.js",
    base + "/assets/v1/logo.png",
    base + "/assets/v1/intro_video.webm",
  );

  // Add Cache to the global so it can be used later during onfetch
  this.caches.set("shell-v1", shellResources);

  // The coast is only clear when all the resources are ready.
  e.waitUntil(shellResources.ready());
});</pre>
    </div>
    <h2>Future extension</h2>
    <p class='critical'>Need to address the requirements from SysApps WG use cases and more. Currently, TaskScheduler and notification would be the scope of this work. Security sensitive features will be considered as V2.</p>

    <h2 class=no-num>References</h2>
    <div id=anolis-references></div>

    <h2 class="no-num" id="acknowledgments">Acknowledgments</h2>

    <p>The editors would like to thank
    Jake ("B.J.") Archibald,
    David Barrett-Kahn,
    Andrew Betts,
    Greg Billock,
    Aaron Boodman,
    Darin Fisher,
    Alec Flett,
    Anne van Kesteren,
    Anssi Kostiainen,
    Dominique Hazael-Massieux,
    Dave Herman,
    Michael Nordman,
    Soledad Penads,
    Michael Sanford,
    Jonas Sicking,
    Chris Wilson,
    Ivan uak
    for their contributions to this specification.</p>

    <p>Thanks also to all those who have helped to improve this specification
    by sending suggestions and corrections. (Please, keep bugging us with your
    issues!)</p>
  </body>
</html>
